#!/usr/bin/python3

# created by: Jon Parker Brooks
# started on: --/--/---- 
# updated on: 03/24/2025
# github: BarkerProoks

from asyncio import run, get_running_loop, DatagramTransport, DatagramProtocol
from asyncio import sleep as asleep
from time import sleep
from sys import argv
from argparse import ArgumentParser

def string_to_addr(address: str) -> tuple[str, int]:
    host, port = address.split(':')
    return host, int(port)


class TunnelCmd:
    CONNECT: bytes = b"\x05"
    CLOSED: bytes = b"\x04"
    SYNACK: bytes = b"\x22"
    ACK: bytes = b"\x06"
    SYN: bytes = b"\x16"


class ProxyBindSocket(DatagramProtocol):
    transport: DatagramTransport | None = None
    addr: tuple[str, int] | None = None

    synack: bytes = TunnelCmd.SYN

    def connection_made(self, transport: DatagramTransport) -> None:
        self.transport = transport

    def datagram_received(self, data: bytes, addr: tuple[str, int]) -> None:
        print("proxy bind recv: ", data)

        if self.synack == TunnelCmd.SYN and data == TunnelCmd.SYN:
            self.synack = TunnelCmd.ACK
            self.transport.sendto(self.synack, addr)
            print("handshake started!")
            
        elif self.synack == TunnelCmd.ACK and data == TunnelCmd.ACK:
            self.transport.sendto(self.synack, addr)
            self.synack = TunnelCmd.SYNACK 
            self.addr = addr
            print("activated!")

    def connection_lost(self, exc) -> None:
        ...

    def error_received(self, exc) -> None:
        ...


class ProxyForwardSocket(DatagramProtocol):
    transport: DatagramTransport | None = None
    addr: tuple[str, int] | None = None

    def __init__(self, addr: tuple[str, int]) -> None:
        self.addr = addr

    def connection_made(self, transport: DatagramTransport) -> None:
        self.transport = transport

    def datagram_received(self, data: bytes, addr: tuple[str, int]) -> None:
        print("proxy forward recv: ", data)
        # every datagram that get's RECV needs to be tunneled back
        self.transport.sendto(data, self.addr)



class LocalBindSocket(DatagramProtocol):
    transport: DatagramTransport | None = None
    synack: bytes = TunnelCmd.SYN

    def connection_made(self, transport: DatagramTransport) -> None:
        print('starting handshake')
        self.transport = transport
        self.transport.sendto(TunnelCmd.SYN)

    def datagram_received(self, data: bytes, addr: tuple[str, int]) -> None:
        print("local recv: ", data)

        if self.synack == TunnelCmd.SYN and data == TunnelCmd.ACK:
            self.transport.sendto(TunnelCmd.ACK)
            self.synack = TunnelCmd.SYNACK
            self.addr = addr

        if self.synack == TunnelCmd.SYNACK:
            self.transport.sendto(self.synack)

    def connection_lost(self, exc) -> None:
        print("connection lost :(")

    def error_received(self, exc) -> None:
        if self.synack == TunnelCmd.SYN or self.synack == TunnelCmd.ACK:
            # not initialized yet, so keep trying
            print("retrying handshake...")
            self.transport.sendto(TunnelCmd.SYN)
            sleep(5)
        else:
            print("local bind server closed")
            self.synack = TunnelCmd.CLOSED


class LocalForwardSocket(DatagramProtocol):
    transport: DatagramTransport | None = None
    addr: tuple[str, int] | None = None

    def __init__(self, addr: tuple[str, int]):
        self.addr = addr

    def connection_made(self, transport: DatagramTransport) -> None:
        self.transport = transport
        self.transport._address = self.addr

    def datagram_received(self, data: bytes, addr: tuple[str, int]) -> None:
        print('tunnel:', data)

    def connection_lost(self, exc) -> None: ...
    def error_received(self, exc) -> None: ...


async def forward_proxy(forward: tuple[str, int], bind: tuple[str, int]) -> tuple[DatagramTransport, DatagramProtocol]:
    socket = lambda: ProxyForwardSocket(bind)
    loop = get_running_loop()
    return await loop.create_datagram_endpoint(socket, local_addr=forward)


async def forward_local(forward: tuple[str, int], bind: tuple[str, int]) -> tuple[DatagramTransport, DatagramProtocol]:
    socket = lambda: LocalForwardSocket(bind)
    loop = get_running_loop()
    return await loop.create_datagram_endpoint(socket, remote_addr=forward)


async def bind_local(bind: tuple[str, int]) -> tuple[DatagramTransport, DatagramProtocol]:
    loop = get_running_loop()
    return await loop.create_datagram_endpoint(LocalBindSocket, remote_addr=bind)


async def bind_proxy(bind: tuple[str, int]) -> tuple[DatagramTransport, DatagramProtocol]:
    loop = get_running_loop()
    return await loop.create_datagram_endpoint(ProxyBindSocket, local_addr=bind)


async def loop_local(forward: tuple[DatagramTransport, ProxyForwardSocket], bind: tuple[DatagramTransport, ProxyBindSocket]):
    forward_transport, forward_protocol = forward
    bind_transport, bind_protocol = bind
    
    while True:
        if bind_protocol.synack == TunnelCmd.SYNACK:
            print("local: activated!")


async def loop_proxy(forward: tuple[DatagramTransport, ProxyForwardSocket], bind: tuple[DatagramTransport, ProxyBindSocket]):
    forward_transport, forward_protocol = forward
    bind_transport, bind_protocol = bind
    
    while True:
        if bind_protocol.synack == TunnelCmd.SYNACK:
            print("proxy: sending heartbeat")
            bind_transport.sendto(TunnelCmd.SYNACK, bind_transport.addr)
            await asleep(2)


def get_parser() -> ArgumentParser:
    parser = ArgumentParser()
    parser.add_argument("mode", choices=("local", "proxy"), type=str)
    parser.add_argument("-f", "--forward", type=str, default="127.0.0.1:8000")
    parser.add_argument("-b", "--bind", type=str, default="127.0.0.1:8001")
    return parser


def close_connections(forward: tuple[DatagramTransport, DatagramProtocol], bind: tuple[DatagramTransport, DatagramProtocol]) -> None:
    forward_transport, _ = forward
    bind_transport, _ = bind
    forward_transport.close()
    bind_transport.close()


async def main():

    args = get_parser().parse_args()
    
    forward_addr = string_to_addr(args.forward)
    bind_addr = string_to_addr(args.bind)

    fs = {
        "local": { "loop": loop_local, "bind": bind_local, "forward": forward_local },
        "proxy": { "loop": loop_proxy, "bind": bind_proxy, "forward": forward_proxy }
    }

    forward = await fs[args.mode]["forward"](forward_addr, bind_addr)
    bind = await fs[args.mode]["bind"](bind_addr)
    loop = fs[args.mode]["loop"]

    try:
        await loop(forward, bind)
    finally:
        print("closing connections")
        close_connections(forward, bind)


run(main())
